


ack() {
	local _dash_i
	local _regex
	if test "${1?}" = -i; then
		_dash_i=-i
		shift
	fi

	_regex=$1
	shift
	find "${@-.}" -name .git -prune -o -type f -exec grep $_dash_i -H "$_regex" {} \;
}
c() { tput sc; clear; tput rc; } # save cursor/restore cursor  man terminfo
cd() {
	local _SESSION_DIR
	local _rv
	local _dir
	_dir=$1
	if test "$#" = 0; then
		_SESSION_DIR=$(tmux show-options -s @dir 2> /dev/null |
			awk -F\" '{print $2}')
	elif test -f "$1" && echo $1 | grep -q /; then
		_dir=$( dirname "$1")
	fi
	command cd "${_dir:-${_SESSION_DIR:-$HOME}}" || return 1;
	test "$PWD" != "$OLDPWD" && : $(( color_index = (color_index + 1) % ${#COLORS}))
	tmux-title;
	return 0
}
cdm() { cd $(get-modified-files | longest-common-prefix -d); }


checkout_previous_branch() {
	local prev_branch
	prev_branch=$(git reflog | awk '$3 == "checkout:"{print $6; exit}') &&
	git checkout "$prev_branch"
	git branch -vv
}
docker() { execute docker "$@" | { while read line; do echo "$line" >&3; echo "$line"; done \
	| sed -nE -e 's/.*([0-9a-f]{12}).*/\1/p' | sed -n -e 1p -n -e '$p' \
	| while read id; do printf "$id" | tmux loadb -; done; } 3>&1
}
du() { ncdu "$@"; }
execute() { cmd=$1; tmux-title "$cmd";
	test "$V" -gt 0 2> /dev/null && echo \$ "$@" >&2;
	command "$@";
	RV=$?; tmux-title; return $RV; }
g() { git "$@"; }
ga() { git add "$@"; git ci -nm "Add $*"; }
gcd() {
	local _dir
	_dir=$(get-modified-files $1 | get-most-used-dir)
	test -d "$_dir" || _dir=$(dirname "$_dir")
	if test -d "$_dir"; then
		cd "$_dir"
		pwd
	else
		echo "$_dir is not a directory" >&2
	fi
}
gdb() { command gdb -tui "$@"; }

gi() {
	local dir sha
	test $# = 0 && { echo 'Expected tarball arg' >&2; return 1; }
	for x; do
		local zip
		test "${x%.tar.gz}" = "$x" || zip=z
		dir="$(set -x; tar -${zip}tf "$x" | awk '{print $1}' FS=/ | sort -u)"
		if ! test "$(echo "$dir" | wc -l | tr -d ' ')" = 1; then
			echo "$x has more than 1 dir or contains newlines:"
			echo "$dir"
			return 1
		fi >&2
		
		test -e "$dir" && { echo $dir exists; return 1; }
		sha=$(md5sum "$x" | cut -d\  -f 1)
		tar -${zip}xf "$x" \
		&& cd $dir \
		&& git init \
		&& git add . \
		&& git ci -n -m "Initial unpack: $sha $(basename $x)"
	done
}
git() {
	case "$1" in
	clone)
		local origin
		# Parse the url to specify a name for origin
		origin=$(echo $2 | awk '{print $3}' FS=[/.])
		if test -n "$origin"; then shift; set -- clone --origin="$origin" "$@"; fi
	;;
	esac
	execute git "$@";
}
gpu() {
	local set_upstream
	if test "$1" = -u; then set_upstream=-u; shift; fi
	remote=${1:-$(g remote | sed -n -e '/^w[^e]/{p; q; }' | grep .)} || {
		echo "No remote to use as default. Specify remote as 1st arg" >&2; return 1; }
	remote_branch=${2:-$(git rev-parse --abbrev-ref HEAD)}
	{ git push $set_upstream "$remote" HEAD:"$remote_branch" 2>&1 >&3 \
		| sed -e '/^remote:/d' >&2; } 3>&1
}
grep() { command grep --color=auto "$@" 2> /dev/null; }

myselect() {
	for x; do echo "$x"; done | expand -t 8 | nl -ba -s ') ' -w 2 | column >&2
	read -p "#? " REPLY
	if test "$REPLY" -ge 0 2> /dev/null; then
		eval SELECTION=\$${REPLY}
	fi
}
irssi() { dtach -A /tmp/irssi.dtach irssi; }
use() {
	# Put the top level git dir of the cwd in the usage file list
	local d; d=$(git rev-parse --show-toplevel) || return
	d="${d#$HOME/}"
	test -n "$d" || return
	local file="$HOME/.config/$USER/usage-list"
	mkdir -p "$(dirname $file)"
	grep -q "^$d$" "$file" || echo "$d" >> "$file"
}

get_dir_list() {
	< $HOME/.config/$USER/usage-list \
	sed -E \
		-e $((${COLUMNS-80} / 5))q \
		-e "s@/.${USER}-usage\$@@" \
		-e 's@.*/([^/]+/[^/]+)$@\1@'
}
j() {
	local _list _dir _dirlist
	while :; do
	case "$1" in
	.) select-git-branch; return;;
	p) checkout_previous_branch; return;;
	'')
		test -z "$_list" && _list=$(get_dir_list)
		myselect $_list
		test -z "$REPLY" && return
		set -- $REPLY;;
	*)
		test -z "$_list" && _list=$(get_dir_list)
		_dir=$(echo "$_list" | { if test "$1" -gt 0 2> /dev/null; then
			filter="${1}"; else filter="/$1/"; fi;
			sed -n -e "${filter}p"; } )
		test -d "$HOME/$_dir" && command cd "$HOME/$_dir" && use
		return
	;;
	esac
	done
}
debug() { test -n "$VERBOSE" && echo "$@" >&2; }
lb() { tr \\n \ | perl -pe 's/ *$//' | tmux loadb - ; }
lba() { { if test $# -gt 1; then "$@"; else cat; fi; } | tmux loadb -; }
less() { if test -t 1; then command less "$@"; else cat "$@"; fi; }
ls() { command ls -GF "$@"; }
mon() { inotifywait -qmr "${@-.}" --exclude '^\./\.git'; }
p() {
	local file
	local base
	local CONFIGGED_PROJECT
	base=${HOME}/.config/gcloud/configurations/config
	file=${base}_${CLOUDSDK_ACTIVE_CONFIG_NAME-default}
	# This is faster than calling gcloud config get-value project,
	# but very fragile
	CONFIGGED_PROJECT=$(if test -f "$file"; then
		awk '/^project =/ {print $3}' $file
	else
		echo 'highly unlikely to match'
	fi )

	local cfg_file=$HOME/.config/$USER/gcloud-project-list
	test -f $cfg_file || gcloud projects list | sed 1d > $cfg_file
	if test -n "$1"; then
		REPLY="$1"
	else
		nl -s ') ' < $cfg_file | sed "/$CONFIGGED_PROJECT/s/^  / */"
		read -p "#? " REPLY
	fi

	if test "$REPLY" -ge 0 2> /dev/null; then
		PROJECT=$(awk 'NR==c{print $1}' c=$REPLY $cfg_file);
		test -n "$PROJECT" || return 1

		CLOUDSDK_ACTIVE_CONFIG_NAME="$PROJECT"
		KUBECONFIG="$HOME"/.config/k8s/"$PROJECT"
		export PROJECT KUBECONFIG CLOUDSDK_ACTIVE_CONFIG_NAME

		file=${base}_${CLOUDSDK_ACTIVE_CONFIG_NAME}
		if ! test -f "$file"; then
			gcloud config configurations create $CLOUDSDK_ACTIVE_CONFIG_NAME
		fi
		gcloud config set project "$PROJECT" || return 1
	fi
	echo PROJECT=$PROJECT
}
ps() { COLUMNS=${CO:-15000} command ps "$@"; }
lh() { history -r ~/.bash-history-dir/shell-pid-$$; }
rh() { history -r $HOME/.bash-history; }
ru () { tac | awk '!a[$0]++' | tac; } ## reverse-unique
rsync() { command rsync -e 'ssh -o LogLevel=error' "$@"; }
s() { search-bash-history "$@"; }
sf() { USE_FAILED=1 search-bash-history "$@"; }
ssh() { test "$1" = "-A" && shift; execute ssh -o LogLevel=error -A "$@"; }
scp() { [[ ! $* =~ : ]] &&
	{ echo 'One of the files should be remote' >&2; return 1; }
	command scp -p -o LogLevel=error "$@"
}
sort() { LC_ALL=C command sort "$@"; }
if ! which tac; then
	if which gtac; then
		tac() { gtac "$@"; }
	else
		tac() { for x; do awk '{a[NR] = $0 }
			END {for(c=NR; c>0; c--) print a[c]}' "$x"; done; }
	fi
fi > /dev/null 2>&1
ta() { EVENT_NOKQUEUE=1 tmux attach; }
tmux-title() { test -t 1 && rename-tmux-pane "$@" 2> /dev/null; }
tn() { tmux switch-client -n; }
tp() { tmux switch-client -p; }
ts() {
  # stdbuf -oL "$@" | perl -pe '$|=1; print localtime . ": "' | ${PAGER-more}
  $@ | perl -pe '$|=1; print localtime . ": "' | ${PAGER-more}
}
typeof() { for e; do which "$e" && file $( which $e ); done }
up() {
	local _dir=$(git rev-parse --show-toplevel)
	test -d "$_dir" && cd "$_dir"
}
vi() { test $# = 0 && set $(get-modified-files ${h});
	vim "$@"; }  # .vimrc handles tmux titles
y() { select-git-branch "$@"; }

for name in man; do
	eval "$name"'() { tmux-title "'"$name"' $1"; command '$name' "$@"; tmux-title; }'
done
