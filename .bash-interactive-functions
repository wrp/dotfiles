


ack() {
	local _dash_i
	local _regex
	if test "${1?}" = -i; then
		_dash_i=-i
		shift
	fi

	_regex=$1
	shift
	find "${@-.}" -name .git -prune -o -type f -exec grep $_dash_i -H "$_regex" {} \;
}
c() { tput sc; clear; tput rc; } # save cursor/restore cursor  man terminfo
cd() {
	local _SESSION_DIR
	local _rv
	local _dir
	_dir=$1
	if test "$#" = 0; then
		_SESSION_DIR=$(tmux show-options -s @dir 2> /dev/null |
			awk -F\" '{print $2}')
	elif test -f "$1" && echo $1 | grep -q /; then
		_dir=$( dirname "$1")
	fi
	command cd "${_dir:-${_SESSION_DIR:-$HOME}}" || return 1;
	test "$PWD" != "$OLDPWD" && : $(( color_index = (color_index + 1) % ${#COLORS}))
	tmux-title;
	# echo "$PS1" | grep -q '@' || { test -t 1 && { printf 'PWD: '; pwd; } }
	return 0
}
cdm() { cd $(get-modified-files | longest-common-prefix -d); }


checkout_previous_branch() {
	local prev_branch
	prev_branch=$(git reflog | awk '$3 == "checkout:"{print $6; exit}') &&
	git checkout "$prev_branch"
	git branch -vv
}
docker() { execute docker "$@" | { while read line; do echo "$line" >&3; echo "$line"; done \
	| sed -nE -e 's/.*([0-9a-f]{12}).*/\1/p' | sed -n -e 1p -n -e '$p' \
	| while read id; do printf "$id" | tmux loadb -; done; } 3>&1
}
du() { ncdu "$@"; }
execute() { cmd=$1; tmux-title "$cmd";
	test "$V" -gt 0 2> /dev/null && echo \$ "$@" >&2;
	command "$@";
	RV=$?; tmux-title; return $RV; }
g() { git "$@"; }
ga() { git add "$@"; git ci -nm "Add $*"; }
gcd() {
	local _dir
	_dir=$(get-modified-files $1 | get-most-used-dir)
	test -d "$_dir" || _dir=$(dirname "$_dir")
	if test -d "$_dir"; then
		cd "$_dir"
		pwd
	else
		echo "$_dir is not a directory" >&2
	fi
}
gdb() { command gdb -tui "$@"; }

gi() {
	local dir sha
	test $# = 0 && { echo 'Expected tarball arg' >&2; return 1; }
	for x; do
		dir="$(tar -tf "$x" | awk '{print $1}' FS=/ | sort -u)"
		if ! test "$(echo "$dir" | wc -l)" = 1; then 
			echo "$x has more than 1 dir or contains newline"
			return 1
		fi >&2
		
		test -e "$dir" && { echo $dir exists; return 1; }
		sha=$(md5sum "$x" | cut -d\  -f 1)
		tar xf "$x" \
		&& cd $dir \
		&& git init \
		&& git add . \
		&& git ci -n -m "Initial unpack: $sha $(basename $x)"
	done
}
git() {
	case "$1" in
	clone)
		local origin
		# Parse the url to specify a name for origin
		origin=$(echo $2 | awk '{print $3}' FS=[/.])
		if test -n "$origin"; then shift; set -- clone --origin="$origin" "$@"; fi
	;;
	esac
	execute git "$@";
}
gpu() {
	local set_upstream
	if test "$1" = -u; then set_upstream=-u; shift; fi
	remote=${1:-$(g remote | sed -n -e '/^w[^e]/{p; q; }' | grep .)} || {
		echo "No remote to use as default. Specify remote as 1st arg" >&2; return 1; }
	remote_branch=${2:-$(git rev-parse --abbrev-ref HEAD)}
	{ git push $set_upstream "$remote" HEAD:"$remote_branch" 2>&1 >&3 \
		| sed -e '/^remote:/d' >&2; } 3>&1
}
grep() { command grep --color=auto "$@" 2> /dev/null; }

myselect() {
	for x; do echo "$x"; done | expand -t 8 | nl -ba -s ') ' -w 2 | column >&2
	read -p "#? " REPLY
	if test "$REPLY" -ge 0 2> /dev/null; then
		eval SELECTION=\$${REPLY}
	fi
}
irssi() { dtach -A /tmp/irssi.dtach irssi; }
use() {
	# Put the top level git dir of the cwd at the top
	# of the usage file list
	local d; d=$(git rev-parse --show-toplevel) || return
	d="${d#$HOME/}"
	test -n "$d" || return
	local file="$HOME/.config/$USER/usage-list"
	mkdir -p "$(dirname $file)"
	{ echo "$d"
	grep -v "$d" "$file"; } > "$file".tmp
	mv "$file".tmp "$file"
}

get_dir_list() {
	< $HOME/.config/$USER/usage-list \
	sed -E \
		-e $((${COLUMNS-80} / 5))q \
		-e "s@/.${USER}-usage\$@@" \
		-e 's@.*/([^/]+/[^/]+)$@\1@'
}
j() {
	local _list _dir _dirlist
	while :; do
	case "$1" in
	.) select-git-branch; return;;
	p) checkout_previous_branch; return;;
	'')
		test -z "$_list" && _list=$(get_dir_list)
		myselect $_list
		test -z "$REPLY" && return
		set -- $REPLY;;
	*)
		test -z "$_list" && _list=$(get_dir_list)
		_dir=$(echo "$_list" | { if test "$1" -gt 0 2> /dev/null; then
			filter="${1}"; else filter="/$1/"; fi;
			sed -n -e "${filter}p"; } )
		test -d "$HOME/$_dir" && command cd "$HOME/$_dir" && use
		return
	;;
	esac
	done
}
jh() { case $1 in poc) ssh -A poc-ansible01;;
	*) V=1 execute ssh -A ${1-prd-adm}-jh.devops.wepay-inc.com; esac; }
debug() { test -n "$VERBOSE" && echo "$@" >&2; }
lb() { tr \\n \ | perl -pe 's/ *$//' | tmux loadb - ; }
lba() { { if test $# -gt 1; then "$@"; else cat; fi; } | tmux loadb -; }
less() { if test -t 1; then command less "$@"; else cat "$@"; fi; }
ls() { command ls -GF "$@"; }
makepkg() { command makepkg --skippgpcheck "$@"; }
mon() { inotifywait -qmr "${@-.}" --exclude '^\./\.git'; }
nb() (
	cd $(git rev-parse --show-toplevel) || exit 1
	case $(basename $(pwd)) in
	uplinux*|upcode*) : ;;
	*) echo 'Make new branches in uplinux or upcode only' >&2; exit 1;;
	esac
	git branch william/$1 master; git checkout william/$1;
)
p() {
	local CONFIGGED_PROJECT=$(awk '/^project =/ {print $3}' \
                 ${HOME}/.config/gcloud/configurations/config_default)

	local cfg_file=$HOME/.config/$USER/gcloud-project-list
	test -f $cfg_file || gcloud projects list | sed 1d > $cfg_file
	nl -s ') ' < $cfg_file | sed "/$CONFIGGED_PROJECT/s/^    / ***/"
	read -p "#? " REPLY
	if test "$REPLY" -ge 0 2> /dev/null; then
		SELECTION=$(awk 'NR==c{print $1}' c=$REPLY $cfg_file);
		export PROJECT="$SELECTION"
		gcloud config set project "$SELECTION"
	fi
}
parse_dir() { # manipulate text to get a handy pathname for a dir
	local _k
	local _first=''
	local _b
	for arg; do
		unset _b
		test -n "$_first" && printf " "  # Emit space on all but first entry
		_first=1
		_k=${arg%%/*}  # Get first path component
		case $arg in
			//*)               _b="${arg#//}";;
		esac

		if test -n "$FILE_TO_DIR" && test -f "$arg"; then
			echo -n ${arg%/*} # If path is a file, return the basename
		fi
	done
	echo
}
ps() { COLUMNS=${CO:-15000} command ps "$@"; }
python() { python2.7 "$@"; }
lh() { history -r ~/.bash-history-dir/shell-pid-$$; }
rh() { history -r $HOME/.bash-history; }
ru () { tac | awk '!a[$0]++' | tac; } ## reverse-unique
rsync() { command rsync -e 'ssh -o LogLevel=error' "$@"; }
s() { search-bash-history "$@"; }
ssh() { test "$1" = "-A" && shift; execute ssh -o LogLevel=error -A "$@"; }
scp() { [[ ! $* =~ : ]] &&
	{ echo 'One of the files should be remote' >&2; return 1; }
	command scp -p -o LogLevel=error "$@"
}
sort() { LC_ALL=C command sort "$@"; }
if ! which tac; then
	if which gtac; then
		tac() { gtac "$@"; }
	else
		tac() { for x; do awk '{a[NR] = $0 }
			END {for(c=NR; c>0; c--) print a[c]}' "$x"; done; }
	fi
fi > /dev/null 2>&1
ta() { EVENT_NOKQUEUE=1 tmux attach; }
tmux-title() { test -t 1 && rename-tmux-pane "$@" 2> /dev/null; }
tn() { tmux switch-client -n; }
tp() { tmux switch-client -p; }
ts() {
  # stdbuf -oL "$@" | perl -pe '$|=1; print localtime . ": "' | ${PAGER-more}
  $@ | perl -pe '$|=1; print localtime . ": "' | ${PAGER-more}
}
typeof() { for e; do which $e && file $( which $e ); done }
um() {
	local _t _b
	_b=$(pwd)
	_t=$(git rev-parse --show-toplevel) || return
	cd $_t
	~/bin/update-master
	cd $_b
}
up() {
	local _dir=$(git rev-parse --show-toplevel)
	test -d "$_dir" && cd "$_dir"
}
vi() { test $# = 0 && set $(get-modified-files ${h});
	vim "$@"; }  # .vimrc handles tmux titles
y() { select-git-branch "$@"; }

for name in man; do
	eval "$name"'() { tmux-title "'"$name"' $1"; command '$name' "$@"; tmux-title; }'
done
