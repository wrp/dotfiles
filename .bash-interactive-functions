


ack() {
	local _dash_i
	local _regex
	if test "${1?}" = -i; then
		_dash_i=-i
		shift
	fi

	_regex=$1
	shift
	find "${@-.}" -name .git -prune -o -type f -exec grep $_dash_i -H "$_regex" {} \;
}
c() { tput sc; clear; tput rc; }
cd() {
	local _SESSION_DIR
	local _rv
	local _dir
	_dir=$1
	if test "$#" = 0; then
		_SESSION_DIR=$(tmux show-options -s @dir 2> /dev/null |
			awk -F\" '{print $2}')
	elif test -f "$1" && echo $1 | grep -q /; then
		_dir=$( dirname "$1")
	fi
	command cd "${_dir:-${_SESSION_DIR:-$HOME}}";
	_rv=$?
	test "$PWD" != "$OLDPWD" && : $(( color_index = (color_index + 1) % ${#COLORS}))
	tmux-title;
	# echo "$PS1" | grep -q '@' || { test -t 1 && { printf 'PWD: '; pwd; } }
	return $_rv
}
cdm() { cd $(get-modified-files | longest-common-prefix -d); }


checkout_previous_branch() {
	local prev_branch
	prev_branch=$(git reflog | awk '$3 == "checkout:"{print $6; exit}') &&
	git checkout "$prev_branch"
	git branch -vv
}
docker() { execute docker "$@" | { while read line; do echo "$line" >&3; echo "$line"; done \
	| sed -nE -e 's/.*([0-9a-f]{12}).*/\1/p' | sed -n -e 1p -n -e '$p' \
	| while read id; do printf "$id" | tmux loadb -; done; } 3>&1
}
execute() { cmd=$1; shift; tmux-title "$cmd";
	test "$V" -gt 0 2> /dev/null && echo Executing: "$cmd" "$@" >&2;
	command "$cmd" "$@";
	RV=$?; tmux-title; return $RV; }
g() { git "$@"; }
ga() { git add "$@"; git ci -nm "Add $*"; }
gcd() {
	local _dir
	_dir=$(get-modified-files $1 | get-most-used-dir)
	test -d "$_dir" || _dir=$(dirname "$_dir")
	test -d "$_dir" && cd "$_dir"
	git branch -vv
	pwd
}
gdb() { command gdb -tui "$@"; }

gi() {
	local dir sha
	test $# = 0 && { echo 'Expected tarball arg' >&2; return 1; }
	for x; do
		dir="$(tar -tf "$x" | awk '{print $1}' FS=/ | sort -u)"
		if ! test "$(echo "$dir" | wc -l)" = 1; then 
			echo "$x has more than 1 dir or contains newline"
			return 1
		fi >&2
		
		test -e "$dir" && { echo $dir exists; return 1; }
		sha=$(md5sum "$x" | cut -d\  -f 1)
		tar xf "$x" \
		&& cd $dir \
		&& git init \
		&& git add . \
		&& git ci -n -m "Initial unpack: $sha $(basename $x)"
	done
}
git() {
	case "$1" in
	clone) long="${2#*//}"; short="${long%%/*}";
		if test -n "$long"; then shift; set -- clone --origin="$short" "$@"; fi
	;;
	esac
	execute git "$@";
}
grep() { command grep ${1:+-R} --color=auto "$@"; }

irssi() { dtach -A /tmp/irssi.dtach irssi; }
j() {
	test "$1" = . && { select-git-branch; return; }
	test "$1" = p && { checkout_previous_branch; return; }
	local _dir _dirlist
	local _list=$(
		find $HOME/{dev,packages,ops} -maxdepth 3 -mindepth 2 -name .git \
		| sed -E -e 's@/.git$@@' -e 's@.*/([^/]+/[^/]+)$@\1@' \
		| sed -e '/^tmp$/d' -e '/^\./d'
	)
	if test "${1-unset}" = unset; then
		select choice in $_list; do break; done
		test -z "$REPLY" && return
		j $REPLY
		return
	fi

	_dir=$(echo "$_list" | { if test "$1" -gt 0 2> /dev/null; then
		filter="${1}"; else filter="/$1/"; fi;
		sed -n -e ${filter}p; } )

	command cd $HOME/$_dir
	select-git-branch
}
jh() { local target=${1-prd-adm}; ssh -A ${target}-jh.devops.wepay-inc.com; }
debug() { test -n "$VERBOSE" && echo "$@" >&2; }
lb() { tr \\n \ | tmux loadb - ; }
lba() { { if test $# -gt 1; then "$@"; else cat; fi; } | tmux loadb -; }
less() { if test -t 1; then command less "$@"; else cat "$@"; fi; }
ls() { command ls -GF "$@"; }
makepkg() { command makepkg --skippgpcheck "$@"; }
mon() { inotifywait -qmr "${@-.}" --exclude '^\./\.git'; }
nb() (
	cd $(git rev-parse --show-toplevel) || exit 1
	case $(basename $(pwd)) in
	uplinux*|upcode*) : ;;
	*) echo 'Make new branches in uplinux or upcode only' >&2; exit 1;;
	esac
	git branch william/$1 master; git checkout william/$1;
)

parse_dir() { # manipulate text to get a handy pathname for a dir
	local _k
	local _first=''
	local _b
	for arg; do
		unset _b
		test -n "$_first" && printf " "  # Emit space on all but first entry
		_first=1
		_k=${arg%%/*}  # Get first path component
		case $arg in
			//*)               _b="${arg#//}";;
		esac

		if test -n "$FILE_TO_DIR" && test -f "$arg"; then
			echo -n ${arg%/*} # If path is a file, return the basename
		fi
	done
	echo
}
ps() { COLUMNS=${CO:-15000} command ps "$@"; }
python() { python2.7 "$@"; }
lh() { history -r ~/.bash-history-dir/shell-pid-$$; }
rh() { history -r $HOME/.bash-history; }
ru () { tac | awk '!a[$0]++' | tac; } ## reverse-unique
rsync() { command rsync -e 'ssh -o LogLevel=error' "$@"; }
s() { search-bash-history "$@"; }
ssh() { test "$1" = "-A" && shift; execute ssh -o LogLevel=error -A "$@"; }
scp() { [[ ! $* =~ : ]] &&
	{ echo 'One of the files should be remote' >&2; return 1; }
	command scp -p -o LogLevel=error "$@"
}
sort() { LC_ALL=C command sort "$@"; }
if ! which -s tac; then
	if which -s gtac; then
		tac() { gtac "$@"; }
	else
		tac() { for x; do awk '{a[NR] = $0 }
			END {for(c=NR; c>0; c--) print a[c]}' "$x"; done; }
	fi
fi
ta() { EVENT_NOKQUEUE=1 tmux attach; }
tmux-title() { test -t 1 && rename-tmux-pane "$@" 2> /dev/null; }
tn() { tmux switch-client -n; }
tp() { tmux switch-client -p; }
ts() {
  # stdbuf -oL "$@" | perl -pe '$|=1; print localtime . ": "' | ${PAGER-more}
  $@ | perl -pe '$|=1; print localtime . ": "' | ${PAGER-more}
}
typeof() { for e; do which $e && file $( which $e ); done }
um() {
	local _t _b
	_b=$(pwd)
	_t=$(git rev-parse --show-toplevel) || return
	cd $_t
	~/bin/update-master
	cd $_b
}
up() {
	local _dir=$(git rev-parse --show-toplevel)
	test -d "$_dir" && cd "$_dir"
}
vi() { test $# = 0 && set $(get-modified-files ${h});
	vim "$@"; }  # .vimrc handles tmux titles
y() { select-git-branch "$@"; }

for name in man; do
	eval "$name"'() { tmux-title "'"$name"' $1"; command '$name' "$@"; tmux-title; }'
done
