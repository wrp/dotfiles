


ack() {
	local _dash_i
	local _regex
	if test "${1?}" = -i; then
		_dash_i=-i
		shift
	fi

	_regex=$1
	shift
	find "${@-.}" -name .git -prune -o -type f -exec grep $_dash_i -H "$_regex" {} \;
}
bundle() {
	local file base
	base=$(g root) || return
	test -d "$base" || return
	file="$base"/$(basename "$base")-$(git rev-parse --short HEAD ).bundle
	test -e "$file" && { echo "$file already exists" >&2; return 1; }
	git bundle create "$file" ${@-HEAD} \
	&& echo Created "$file"
}
c() { tput sc; clear; tput rc; } # save cursor/restore cursor  man terminfo
cd() {
	local _SESSION_DIR
	local _rv
	local _dir
	_dir=$1
	if test $# -gt 1; then
		echo 'cd takes at most one argument' >&2
		return 1
	fi
	if test "$#" = 0; then
		_SESSION_DIR=$(tmux show-options -s @dir 2> /dev/null |
			awk -F\" '{print $2}')
	elif test -f "$1" && echo $1 | grep -q /; then
		_dir=$( dirname "$1")
		echo cd: Truncating target to $_dir >&2
	fi
	command cd "${_dir:-${_SESSION_DIR:-$HOME}}" || return 1;
	test "$PWD" != "$OLDPWD" && : $(( color_index = (color_index + 1) % ${#COLORS}))
	tmux-title;
	setup_vars

	# Force pwd to report realpath with this terrible hack
	test "$(pwd 2> /dev/null)" != "$(realpath .)" && command cd $(realpath .)

	# If actual cd fails, we returned 1 above.
	# Don't care about failures now.
	return 0
}
cdm() { cd $(get-modified-files | longest-common-prefix -d); }


checkout_previous_branch() {
	echo "Don't use ${FUNCNAME[0]} anymore!  Just do 'git checkout -' or 'git checkout @{-1}'" >&2
	return
	local prev_branch
	if prev_branch=$(git reflog | awk '$3 == "checkout:"{print $6; exit}' | grep .); then
		git checkout "$prev_branch"
	else
		echo "Couldn't determine previous branch from reflog" >&2
		return 1
	fi
}
curl() { command curl -Ss "$@"; }
du() { ncdu "$@"; }
execute() { local cmd=$1; tmux-title "$cmd";
	test "$V" -gt 0 2> /dev/null && echo \$ "$@" >&2;
	command "$@";
	RV=$?; tmux-title; return $RV; }
g() {
	# Basically, this is a wrapper around git.  Plus we do some post-processing.
	# Passing . as first arg allows us to just do the post-processing.
	local rv=0 root
	case $1 in
	( .    ) : ;;
	( root )
		root=$(git rev-parse --git-dir) \
		&& root=$(cd "$root" && pwd 2> /dev/null)/ \
		&& echo "${root%%/.git/*}";;
	( *    ) git "$@";;
	esac
	rv=$?
	setup_vars
	return $rv
}
ga() {
	# When running on both docker and outside, the repos seem to get corrupt
	# in such a way that `git status` cleans it up.  (That is, git diff-index
	# will fail until `git status` is run in that environment.)  So run
	# git status to "uncorrupt" the repo.  Terrible hack.
	git status > /dev/null
	if git rev-parse HEAD > /dev/null 2>&1 \
			&& ! git diff-index --quiet HEAD; then
		echo Repo is dirty >&2
		return 1
	fi
	git add "$@";
	list=$(git diff --name-only --cached | tr \\n \ )
	git ci -nm "Add $list";
}
gcd() {
	local _dir
	_dir=$(get-modified-files $1 | get-most-used-dir)
	test -d "$_dir" || _dir=$(dirname "$_dir")
	if test -d "$_dir"; then
		cd "$_dir"
		pwd
	else
		echo "$_dir is not a directory" >&2
	fi
}
gdb() { command gdb -tui "$@"; }
GET() {
	# ACCESS_TOKEN will need be refreshed periodically.  Just unset it.
	test -z "$ACCESS_TOKEN" \
		&& ACCESS_TOKEN="$(gcloud auth application-default print-access-token)"
	curl -H "Authorization: Bearer $ACCESS_TOKEN" "$@"
}

gi() {
	local dir sha
	test $# = 0 && { echo 'Expected tarball arg' >&2; return 1; }
	for x; do
		local zip
		test "${x%.tar.gz}" = "$x" || zip=z
		dir="$(set -x; tar -${zip}tf "$x" | awk '{print $1}' FS=/ | sort -u)"
		if ! test "$(echo "$dir" | wc -l | tr -d ' ')" = 1; then
			echo "$x has more than 1 dir or contains newlines:"
			echo "$dir"
			return 1
		fi >&2

		test -e "$dir" && { echo $dir exists; return 1; }
		sha=$(md5sum "$x" | cut -d\  -f 1)
		tar -${zip}xf "$x" \
		&& cd $dir \
		&& git init \
		&& git add . \
		&& git ci -n -m "Initial unpack: $sha $(basename $x)"
	done
}
git() {
	case "$1" in
	clone)
		local origin
		# Parse the url to specify a name for origin
		case $2 in
		http*) test -n "$HTTP_OK" ||
			{ echo "Use ssh or set HTTP_OK!!" >&2; return 1; } ;;
		ssh://git@github.*) origin=github;;
		ssh://git@bitbucket.devops.wepay-inc.*) origin=wepay;;
		esac
		shift;
		test -n "$origin" && echo "Setting origin=$origin"
		set -- clone ${origin:+--origin="$origin"} "$@";
	;;
	esac
	execute git "$@";
}
gpu() {
	local set_upstream
	if test "$1" = -u; then set_upstream=-u; shift; fi
	remote=${1:-$(g remote | sed -n -e '/^w[^e]/{p; q; }' | grep .)} || {
		echo "No remote to use as default. Specify remote as 1st arg" >&2; return 1; }
	remote_branch=${2:-$(git rev-parse --abbrev-ref HEAD)}
	{ git push $set_upstream "$remote" HEAD:"$remote_branch" 2>&1 >&3 \
		| sed -e '/^remote:/d' >&2; } 3>&1
}
grep() {
	if test -t 1; then
		command grep --color=always "$@" | ${PAGER-more}
		return ${PIPESTATUS[0]}
	else
		command grep --color=auto "$@"
	fi
}

wrpselect() {
	local -a args
	unset REPLY
	unset SELECTION
	REPLY=$#
	case $# in
	1)
		SELECTION=$1
		;;
	0)
		;;
	*)
		for x; do echo "$x"; done | expand -t 8 | nl -ba -s ') ' -w 2 | column >&2
		read -p "#? " REPLY
		if test "$REPLY" -ge 0 2> /dev/null; then
			eval SELECTION=\${${REPLY}}
		elif test -z "$REPLY"; then
			return;
		else
			for x; do
				if echo "$x" | grep -q "$REPLY"; then
					args+=("$x")
				fi
			done
			wrpselect "${args[@]}"
		fi
		;;
	esac
}
irssi() { dtach -A /tmp/irssi.dtach irssi; }
use() {
	# Put the top level git dir of the cwd in the usage file list
	local d root
	root="${USE_HOME:-$HOME}"
	d=$(cd "${1-.}"; g root) || return
	d="${d#$root/}"
	test -n "$d" || { echo "Don't try to use $root" >&2; return; }
	local file="$root/.config/$USER/usage-list"
	mkdir -p "$(dirname $file)"
	touch "$file"
	if ! grep -q "^$d$" "$file"; then
		content=$( { cat "$file"; echo "$d"; } | sort ) \
		&& echo "$content" > $file
	fi
}
unuse() {
	local d
	root="${USE_HOME:-$HOME}"
	d=$(cd "${1-.}"; g root) || return
	d="${d#$root/}"
	local file="$root/.config/$USER/usage-list"
	content=$( grep -v "^$d$" "$file" ) \
	&& echo "$content" > $file
}

get_dir_list() {
	local root="${USE_HOME:-$HOME}"
	if test "$1" -gt 0 2> /dev/null; then
		sed -n -e "${1}p"
	else
		sed -n -e "\@${1:-.}@p"
	fi < $root/.config/$USER/usage-list
}
j() {
	local _dir
	local root="${USE_HOME:-$HOME}"
	case "$1" in
	.)
		select-git-branch;;
	*)
		wrpselect $(get_dir_list "$1")
		_dir=$SELECTION
		test -n "$_dir" || return
		if ! test -d "$root/$_dir"; then
			echo "$root/$_dir does not exist!" >&2
		else
			command cd "$root/$_dir"
			pwd
		fi
	;;
	esac
	g .
}
_j_complete() {
	local curr_word=${COMP_WORDS[$COMP_CWORD]}
	list=$(get_dir_list "$curr_word")
	COMPREPLY=($(echo "$list" | tr ' ' \\n | grep "$curr_word"))
}
complete -o default -F _j_complete j
debug() { test -n "$VERBOSE" && echo "$@" >&2; }
lb() { tr \\n \ | perl -pe 's/ *$//' | tmux loadb - ; }
lba() { { if test $# -gt 1; then "$@"; else cat; fi; } | tmux loadb -; }
less() { if test -t 1; then command less "$@"; else cat "$@"; fi; }
ls() { command ls -GF "$@"; }
mon() { inotifywait -qmr "${@-.}" --exclude '^\./\.git'; }
p() {
	local line
	local file
	local base
	local CONFIGGED_PROJECT
	base=${HOME}/.config/gcloud/configurations/config
	file=${base}_${CLOUDSDK_ACTIVE_CONFIG_NAME-default}
	# This is faster than calling gcloud config get-value project,
	# but very fragile
	CONFIGGED_PROJECT=$(awk '/^project =/ {print $3}' "$file" 2> /dev/null)
	if test -z "$CONFIGGED_PROJECT"; then
		printf "%s..." "Unable to determine project. Querying"
		CONFIGGED_PROJECT=$( gcloud config get-value project 2> /dev/null )
		if test -z "$CONFIGGED_PROJECT"; then
		        printf "\n" >&3
			printf "\nNo currently configured project.  Please run"
			printf " 'gcloud config set project \$PROJECT'\n"
			printf "You can get list of possible options from "
			printf "'gcloud projects list'\n"
			return 1
		fi >&2 3>&1
		printf "ok.  Using $CONFIGGED_PROJECT\n"
	fi

	local cfg_file=$HOME/.config/$USER/gcloud-project-list
	test -f $cfg_file || gcloud projects list | sed 1d > $cfg_file
	if test -n "$1"; then
		REPLY="$1"
	else
		nl -s ') ' < $cfg_file | sed "/$CONFIGGED_PROJECT/s/^  / */"
		read -p "#? " REPLY
	fi

	if test "$REPLY" -ge 0 2> /dev/null; then
		line=$(awk 'NR==c{print $0}' c=$REPLY $cfg_file);
	else
		line=$(awk '$1~c{print $0}' c=$REPLY $cfg_file);
	fi

	test -z "$line" && return 1
	read PROJECT PROJECT_NAME _ <<< $line
	test -n "$PROJECT" || return 1

	CLOUDSDK_ACTIVE_CONFIG_NAME="$PROJECT"
	KUBECONFIG="$HOME"/.config/k8s/"$PROJECT"
	export PROJECT PROJECT_NAME KUBECONFIG CLOUDSDK_ACTIVE_CONFIG_NAME

	file=${base}_${CLOUDSDK_ACTIVE_CONFIG_NAME}
	if ! test -f "$file"; then
		gcloud config configurations create $CLOUDSDK_ACTIVE_CONFIG_NAME
	fi
	gcloud config set project "$PROJECT" || return 1
	echo PROJECT=$PROJECT
}
ps() { COLUMNS=${CO:-15000} command ps "$@"; }
push() { kill -s SIGUSR1 $(ls $HOME/.bash-history-dir | sed 's/shell-pid-//g'); }
POST() {
	# ACCESS_TOKEN will need be refreshed periodically.  Just unset it.
	test -z "$ACCESS_TOKEN" \
		&& ACCESS_TOKEN="$(gcloud auth application-default print-access-token)"
	curl -X POST -H "Authorization: Bearer $ACCESS_TOKEN" "$@"
}
PUT() {
	# ACCESS_TOKEN will need be refreshed periodically.  Just unset it.
	test -z "$ACCESS_TOKEN" \
		&& ACCESS_TOKEN="$(gcloud auth application-default print-access-token)"
	curl -X PUT -H "Authorization: Bearer $ACCESS_TOKEN" "$@"
}
rh() { history -r $HOME/.bash-history; }
ru () { tac | awk '!a[$0]++' | tac; } ## reverse-unique
rsync() { command rsync -e 'ssh -o LogLevel=error' "$@"; }
s() { search-bash-history "$@"; }
setup_vars() {
	# Assign some variables for the shell
	local b
	if b=$(V=0 git rev-parse --abbrev-ref HEAD 2> /dev/null ); then
		if test "$branch" != "$b"; then
			branch=$b
			if test -n "$V"; then echo "Setting branch=$branch"; fi
		else
			if test -n "$V"; then echo "Variable branch unchanged: $branch"; fi
		fi
	else
		unset branch
		if test -n "$V"; then echo 'Unsetting branch'; fi
	fi
	local r
	if { r=$(V=0 git config branch.$(V=0 git name-rev --name-only HEAD).remote); } 2> /dev/null; then
		if test "$remote" != "$r"; then
			remote=$r
			if test -n "$V"; then echo "Setting remote=$remote"; fi
		else
			if test -n "$V"; then echo "Variable remote unchanged: $remote"; fi
		fi
	else
		unset remote
		if test "$V" = 1; then echo 'Unsetting remote'; fi
	fi
}
sf() { USE_FAILED=1 search-bash-history "$@"; }
ssh() { tmux-title "$@"; command ssh -o LogLevel=error "$@"; tmux-title; }
scp() { [[ ! $* =~ : ]] &&
	{ echo 'One of the files should be remote' >&2; return 1; }
	command scp -p -o LogLevel=error "$@"
}
sort() { LC_ALL=C command sort "$@"; }
if ! which tac; then
	if which gtac; then
		tac() { gtac "$@"; }
	else
		tac() { for x; do awk '{a[NR] = $0 }
			END {for(c=NR; c>0; c--) print a[c]}' "$x"; done; }
	fi
fi > /dev/null 2>&1

ta() { EVENT_NOKQUEUE=1 tmux attach; }
if test -n "$TMUX"; then
	ta() { echo 'Already in a tmux session' >&2; }
fi
tmux-title() { test -t 1 || return;
	while test "${1#-}" != "$1"; do shift; done;
	rename-tmux-window "$@"; }
tn() { tmux switch-client -n; }
tp() { tmux switch-client -p; }
trim() { perl -nE "chomp; say substr \$_, 0, ${COLUMNS-80} - 1" "$@"; }
ts() {
  # stdbuf -oL "$@" | perl -pe '$|=1; print localtime . ": "' | ${PAGER-more}
  $@ | perl -pe '$|=1; print localtime . ": "' | ${PAGER-more}
}
typeof() { for e; do which "$e" && file $( which $e ); done }
up() {
	local _dir=$(g root)
	test -d "$_dir" && cd "$_dir"
}
update() {
	local cmd=update
	local pfx=.
	# -ef tests if the two paths refer to the same file.  This
	# seems to work on both macos and linux, but is non-standard.
	until test -x $pfx/$cmd || test $pfx -ef ../$pfx; do
		pfx=../$pfx
	done
	if test -x $pfx/$cmd; then
		$pfx/$cmd "$@"
	else
		echo Unable to find update command looking up in filesystem >&2
	fi
}
vi() { test $# = 0 && set $(get-modified-files ${h});
	vim "$@"; }  # .vimrc handles tmux titles
y() { select-git-branch "$@"; }

for name in man; do
	eval "$name"'() { tmux-title "'"$name"' $1"; command '$name' "$@"; tmux-title; }'
done
