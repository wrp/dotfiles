


ack() {
	local _dash_i
	local _regex
	if test "${1?}" = -i; then
		_dash_i=-i
		shift
	fi

	_regex=$1
	shift
	find "${@-.}" -name .git -prune -o -type f -exec grep $_dash_i -H "$_regex" {} \;
}
c() { tput sc; clear; tput rc; } # save cursor/restore cursor  man terminfo
cd() {
	local _SESSION_DIR
	local _rv
	local _dir
	_dir=$1
	if test "$#" = 0; then
		_SESSION_DIR=$(tmux show-options -s @dir 2> /dev/null |
			awk -F\" '{print $2}')
	elif test -f "$1" && echo $1 | grep -q /; then
		_dir=$( dirname "$1")
		echo cd: Truncating target to $_dir >&2
	fi
	command cd "${_dir:-${_SESSION_DIR:-$HOME}}" || return 1;
	test "$PWD" != "$OLDPWD" && : $(( color_index = (color_index + 1) % ${#COLORS}))
	tmux-title;
	return 0
}
cdm() { cd $(get-modified-files | longest-common-prefix -d); }


checkout_previous_branch() {
	local prev_branch
	prev_branch=$(git reflog | awk '$3 == "checkout:"{print $6; exit}') &&
	git checkout "$prev_branch"
	git branch -vv
}
curl() { command curl -Ss "$@"; }
docker() { execute docker "$@" | { while read line; do echo "$line" >&3; echo "$line"; done \
	| sed -nE -e 's/.*([0-9a-f]{12}).*/\1/p' | sed -n -e 1p -n -e '$p' \
	| while read id; do printf "$id" | tmux loadb -; done; } 3>&1
}
du() { ncdu "$@"; }
execute() { cmd=$1; tmux-title "$cmd";
	test "$V" -gt 0 2> /dev/null && echo \$ "$@" >&2;
	command "$@";
	RV=$?; tmux-title; return $RV; }
g() { git "$@"; }
ga() {
	if ! git diff-index --quiet HEAD; then
		echo repo is dirty >&2
		return 1
	fi
	git add "$@";
	list=$(git diff --name-only --cached | tr \\n \ )
	git ci -nm "Add $list";
}
gcd() {
	local _dir
	_dir=$(get-modified-files $1 | get-most-used-dir)
	test -d "$_dir" || _dir=$(dirname "$_dir")
	if test -d "$_dir"; then
		cd "$_dir"
		pwd
	else
		echo "$_dir is not a directory" >&2
	fi
}
gdb() { command gdb -tui "$@"; }
GET() {
	# ACCESS_TOKEN will need be refreshed periodically.  Just unset it.
	test -z "$ACCESS_TOKEN" \
		&& ACCESS_TOKEN="$(gcloud auth application-default print-access-token)"
	curl -H "Authorization: Bearer $ACCESS_TOKEN" "$@"
}

gi() {
	local dir sha
	test $# = 0 && { echo 'Expected tarball arg' >&2; return 1; }
	for x; do
		local zip
		test "${x%.tar.gz}" = "$x" || zip=z
		dir="$(set -x; tar -${zip}tf "$x" | awk '{print $1}' FS=/ | sort -u)"
		if ! test "$(echo "$dir" | wc -l | tr -d ' ')" = 1; then
			echo "$x has more than 1 dir or contains newlines:"
			echo "$dir"
			return 1
		fi >&2
		
		test -e "$dir" && { echo $dir exists; return 1; }
		sha=$(md5sum "$x" | cut -d\  -f 1)
		tar -${zip}xf "$x" \
		&& cd $dir \
		&& git init \
		&& git add . \
		&& git ci -n -m "Initial unpack: $sha $(basename $x)"
	done
}
git() {
	case "$1" in
	clone)
		local origin
		# Parse the url to specify a name for origin
		origin=$(echo $2 | awk '{print $3}' FS=[/.])
		if test -n "$origin"; then shift; set -- clone --origin="$origin" "$@"; fi
	;;
	esac
	execute git "$@";
}
gpu() {
	local set_upstream
	if test "$1" = -u; then set_upstream=-u; shift; fi
	remote=${1:-$(g remote | sed -n -e '/^w[^e]/{p; q; }' | grep .)} || {
		echo "No remote to use as default. Specify remote as 1st arg" >&2; return 1; }
	remote_branch=${2:-$(git rev-parse --abbrev-ref HEAD)}
	{ git push $set_upstream "$remote" HEAD:"$remote_branch" 2>&1 >&3 \
		| sed -e '/^remote:/d' >&2; } 3>&1
}
grep() { command grep --color=auto "$@"; }

myselect() {
	unset REPLY
	unset SELECTION
	REPLY=$#
	case $# in
	1)
		SELECTION=$1
		;;
	0)
		;;
	*)
		for x; do echo "$x"; done | expand -t 8 | nl -ba -s ') ' -w 2 | column >&2
		read -p "#? " REPLY
		if test "$REPLY" -ge 0 2> /dev/null; then
			eval SELECTION=\${${REPLY}}
		fi
		;;
	esac
}
irssi() { dtach -A /tmp/irssi.dtach irssi; }
use() {
	# Put the top level git dir of the cwd in the usage file list
	local d; d=$(git rev-parse --show-toplevel) || return
	d="${d#$HOME/}"
	test -n "$d" || { echo "Don't try to use $HOME" >&2; return; }
	local file="$HOME/.config/$USER/usage-list"
	mkdir -p "$(dirname $file)"
	if ! grep -q "^$d$" "$file"; then
		content=$( { cat "$file"; echo "$d"; } | sort ) \
		&& echo "$content" > $file
	fi
}

get_dir_list() {
	if test "$1" -gt 0 2> /dev/null; then
		sed -n -e "${1}p"
	else
		sed -n -e "/${1:-.}/p"
	fi < $HOME/.config/$USER/usage-list

	# | sed -e $((${COLUMNS-80} / 5))q
}
j() {
	local _dir
	case "$1" in
	.) select-git-branch;;
	p) checkout_previous_branch;;
	*)
		myselect $(get_dir_list "$1")
		_dir=$SELECTION
		test -n "$_dir" \
		&& test -d "$HOME/$_dir" \
		&& command cd "$HOME/$_dir" \
		&& use
	;;
	esac
}
debug() { test -n "$VERBOSE" && echo "$@" >&2; }
lb() { tr \\n \ | perl -pe 's/ *$//' | tmux loadb - ; }
lba() { { if test $# -gt 1; then "$@"; else cat; fi; } | tmux loadb -; }
less() { if test -t 1; then command less "$@"; else cat "$@"; fi; }
ls() { command ls -GF "$@"; }
mon() { inotifywait -qmr "${@-.}" --exclude '^\./\.git'; }
p() {
	local line
	local file
	local base
	local CONFIGGED_PROJECT
	base=${HOME}/.config/gcloud/configurations/config
	file=${base}_${CLOUDSDK_ACTIVE_CONFIG_NAME-default}
	# This is faster than calling gcloud config get-value project,
	# but very fragile
	CONFIGGED_PROJECT=$(if test -f "$file"; then
		awk '/^project =/ {print $3}' $file
	else
		echo 'highly unlikely to match'
	fi )

	local cfg_file=$HOME/.config/$USER/gcloud-project-list
	test -f $cfg_file || gcloud projects list | sed 1d > $cfg_file
	if test -n "$1"; then
		REPLY="$1"
	else
		nl -s ') ' < $cfg_file | sed "/$CONFIGGED_PROJECT/s/^  / */"
		read -p "#? " REPLY
	fi

	if test "$REPLY" -ge 0 2> /dev/null; then
		line=$(awk 'NR==c{print $0}' c=$REPLY $cfg_file);
		read PROJECT PROJECT_NAME _ <<< $line
		test -n "$PROJECT" || return 1

		CLOUDSDK_ACTIVE_CONFIG_NAME="$PROJECT"
		KUBECONFIG="$HOME"/.config/k8s/"$PROJECT"
		export PROJECT PROJECT_NAME KUBECONFIG CLOUDSDK_ACTIVE_CONFIG_NAME

		file=${base}_${CLOUDSDK_ACTIVE_CONFIG_NAME}
		if ! test -f "$file"; then
			gcloud config configurations create $CLOUDSDK_ACTIVE_CONFIG_NAME
		fi
		gcloud config set project "$PROJECT" || return 1
	fi
	echo PROJECT=$PROJECT
}
ps() { COLUMNS=${CO:-15000} command ps "$@"; }
push() { kill -s SIGUSR1 $(ls $HOME/.bash-history-dir | sed 's/shell-pid-//g'); }
POST() {
	# ACCESS_TOKEN will need be refreshed periodically.  Just unset it.
	test -z "$ACCESS_TOKEN" \
		&& ACCESS_TOKEN="$(gcloud auth application-default print-access-token)"
	curl -X POST -H "Authorization: Bearer $ACCESS_TOKEN" "$@"
}
PUT() {
	# ACCESS_TOKEN will need be refreshed periodically.  Just unset it.
	test -z "$ACCESS_TOKEN" \
		&& ACCESS_TOKEN="$(gcloud auth application-default print-access-token)"
	curl -X PUT -H "Authorization: Bearer $ACCESS_TOKEN" "$@"
}
rh() { history -r $HOME/.bash-history; }
ru () { tac | awk '!a[$0]++' | tac; } ## reverse-unique
rsync() { command rsync -e 'ssh -o LogLevel=error' "$@"; }
s() { search-bash-history "$@"; }
sf() { USE_FAILED=1 search-bash-history "$@"; }
ssh() { test "$1" = "-A" && shift; execute ssh -o LogLevel=error -A "$@"; }
scp() { [[ ! $* =~ : ]] &&
	{ echo 'One of the files should be remote' >&2; return 1; }
	command scp -p -o LogLevel=error "$@"
}
sort() { LC_ALL=C command sort "$@"; }
if ! which tac; then
	if which gtac; then
		tac() { gtac "$@"; }
	else
		tac() { for x; do awk '{a[NR] = $0 }
			END {for(c=NR; c>0; c--) print a[c]}' "$x"; done; }
	fi
fi > /dev/null 2>&1
ta() { EVENT_NOKQUEUE=1 tmux attach; }
tmux-title() { test -t 1 && rename-tmux-pane "$@" 2> /dev/null; }
tn() { tmux switch-client -n; }
tp() { tmux switch-client -p; }
ts() {
  # stdbuf -oL "$@" | perl -pe '$|=1; print localtime . ": "' | ${PAGER-more}
  $@ | perl -pe '$|=1; print localtime . ": "' | ${PAGER-more}
}
typeof() { for e; do which "$e" && file $( which $e ); done }
up() {
	local _dir=$(git rev-parse --show-toplevel)
	test -d "$_dir" && cd "$_dir"
}
vi() { test $# = 0 && set $(get-modified-files ${h});
	vim "$@"; }  # .vimrc handles tmux titles
y() { select-git-branch "$@"; }

for name in man; do
	eval "$name"'() { tmux-title "'"$name"' $1"; command '$name' "$@"; tmux-title; }'
done
