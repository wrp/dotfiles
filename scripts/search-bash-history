#!/bin/bash

# Search for commands in .bash-history and provide an interface
# to store one in a tmux buffer

die() { test -n "*" && echo "$@"; exit 1; }
HIST=$HOME/.config/$USER/bash-search-history

tac=$(which tac || which gtac)
buffer_name=history_search
: ${max_lines=15}

if test "$1" -ge 0 2> /dev/null; then
	choice=$1
	shift
fi

if test $# = 0; then
	read cmds < $HIST
	set -- $cmds
	test $# = 0 && die 'no search terms given and no history'
else
	echo "$*" > $HIST.tmp
	test -r $HIST && sed -e "\@^$*\$@d" $HIST >> $HIST.tmp
	mv $HIST.tmp $HIST
fi

trap 'rm -f $tmp1 $tmp2' 0
tmp1=$(mktemp)
tmp2=$(mktemp)

# Prepend "?:" to every command that is in the history before
# we started recording status. Also, ignore FAILED commands conditionally.
# This relies on the formatting given in the PROMPT_COMMAND in .bashrc
< ~/.bash-history \
	awk '
		/^#.*FAILED/{ seen = 1 }
		/^#/ && seen { status = match($0,"^#.*FAILED") ? "!" : "" }
		!/^#/ && ( printfailed || status != "!") {
			printf "%2s: %s\n", status, $0
		}
	' status='?' printfailed=${USE_FAILED+1} \
> $tmp1

for pattern; do
	unset negate
	if test "${pattern:0:1}" = '~'; then
		negate=-v
		pattern="${pattern:1}"
	fi
	grep -E -i ${negate} "${pattern}" $tmp1 > $tmp2
	mv $tmp2 $tmp1
done

# Unique the entries and ignore 's' command.
< $tmp1 $tac \
| awk '!/^s / && !a[$0]++' \
> $tmp2
mv $tmp2 $tmp1

test -s $tmp1 || exit 0

if test -z "$choice"; then
	< $tmp1 \
	sed "${max_lines}q" \
		| nl -s '' -w 2 -ba | expand | $tac \
		| perl -nE 'chop; say substr $_, 0, '"${COLUMNS-80} - 1"

	printf 'Select command to store in tmux buffer: '
	read n
else
	n=$choice
fi

if test "$n" -gt 0 2> /dev/null; then
	sed -n -e "${n}s/^..: //" -e "$n"p $tmp1 \
	| tr -d \\n | tmux loadb -b ${buffer_name?} -
elif test -n "$n"; then
	printf "%s" "$n" | tmux loadb -b ${buffer_name?} -
else
	echo
	exit 0
fi

# Let interactive prompt print
{ sleep .2; tmux paste-buffer -b ${buffer_name?} ; } &
