color() {
	# Output sequences to print "$*" in the color specified in $1.
	# Most terminals do not allow us to restore only the attributes, but
	# we can restore position and attributes.  This function emits a
	# string which saves position/attributes, changes color, writes the
	# string, restores position/attributes, and then moves to the end
	# of the string.

	local length msg color
	color=${1}
	shift
	msg="$*"
	case $color in
	black)    color=0;;
	red)      color=1;;
	green)    color=2;;
	yellow)   color=3;;
	blue)     color=4;;
	magenta)  color=5;;
	cyan)     color=6;;
	white)    color=7;;
	*)        color=9;;
	esac
	length=$(printf '%s' "$msg" | wc -c)
	tput sc
	tput setaf "$color"
	printf '%s' "$msg"
	tput rc
	tput cuf "$length"
}

die() {
	local header=FATAL
	if test -t 1; then
		header=$(color red $header)
	fi
	STFU= header=$header warn "$@"
	exit 1
} >&2

unset header
warn() {
	local name=$(basename "${0}")
	test -n "$STFU" && return
	local prefix=$(printf '[%s] %s%s' "${header-WARNING}" "$name" "${*:+: }")
	printf "${prefix}%s\n" "$@"
} >&2

_run_file() {
	local hook=$1
	local index_hash
	shift
	if test -x "$hook"; then
		index_hash=$(git ls-files -s | md5sum -)
		"$hook" "$@" || die "$hook failed"
		if test "$(git ls-files -s | md5sum -)" != "$index_hash"; then
			die "$hook modified the index"
		fi
	elif test -e "$hook"; then
		warn "$hook exists but is not executable"
	fi
}

run_local_hooks() {
	# If $GIT_DIR/local-hooks/ exists, execute scripts there.
	# Note that this does not attempt to duplicate stdin to the
	# script, as that functionality has not yet been necessary.
	local hook_file="$(dirname $(dirname $0))/local-hooks/$(basename $0)"
	local hook_dir="${hook_file}.d"
	local hook

	for hook in "$hook_file" "$hook_dir"/*; do
		_run_file "$hook" "$@"
	done
}

is_subproject() {
	git rev-parse --show-superproject-working-tree | grep -q .
}
