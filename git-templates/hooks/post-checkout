#!/bin/sh

get_remote() {
	remote=$( {
		git rev-parse --symbolic-full-name --abbrev-ref @{u} 2> /dev/null \
		|| git rev-parse --symbolic-full-name --abbrev-ref main@{u} 2> /dev/null \
		|| git rev-parse --symbolic-full-name --abbrev-ref master@{u} 2> /dev/null \
		; } | cut -d / -f 1 )
}

get_branch() {
	branch=$(git branch --show-current)
	local i p
	if test -z "$branch"; then
		# Maybe we are rebasing; try to get the original branch name
		for i in rebase-merge rebase-apply; do
			p=$(git rev-parse --git-path $i)
			if test -d "$p"; then
				branch=$(sed -e 's@refs/heads/@@' "$p"/head-name)
				break;
			fi
		done
	fi
}

get_names_for_remote() {
	get_remote
	url=$( git ls-remote --get-url "$remote" 2> /dev/null )

	while read project email name; do
		test -z "$project" && continue
		case $url in
		*github.com:${project}*)
			EMAIL="${email-$EMAIL}"
			UNAME="${name-$UNAME}"
		break
		;;
		esac
	done <<- EOF
	    $GITHUB
	EOF
}

main() {
	get_branch
	branch_email=$(git config branch.$branch.email)

	if test -n "$branch_email"; then
		EMAIL=$branch_email
	else
		get_names_for_remote
	fi

	git config user.email "${EMAIL?}"
	git config user.name "${UNAME?}"

	if ! git rev-parse --show-superproject-working-tree | grep -q . \
		&& test -z "$STFU" \
	; then
		printf >&2 "name/email set to %s/%s\n" "${UNAME}" "${EMAIL}"
	fi
}

main "$@"
