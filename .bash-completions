GIT_COMPLETE_REVLIST_MAX=1500

# Better to use __git_complete from
# curl -O https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash
# But let's leave this here for the times that may be unavailable
if test -r "$HOME/.config/$USER/git-completion.bash"; then
	source "$HOME/.config/$USER/git-completion.bash"
	# Sigh.  git-completion from that site is broken.  Apply:
#  diff --git a/git-completion.bash b/git-completion.bash
#  index 4262236..7a25df6 100644
#  --- a/git-completion.bash
#  +++ b/git-completion.bash
#  @@ -3778,7 +3778,7 @@ __git_main ()
#                          then
#                                  __gitcomp "$GIT_TESTING_PORCELAIN_COMMAND_LIST"
#                          else
#  -                               local list_cmds=list-mainporcelain,others,nohelpers,alias,list-complete,config
#  +                               local list_cmds=list-mainporcelain,others,nohelpers,alias,list-complete,config,main
#
#                                  if test "${GIT_COMPLETION_SHOW_ALL_COMMANDS-}" = "1"
#                                  then
#

	__git_complete g __git_main
	__git_complete git __git_main
else
_git_find_repo() {
	local path="$1"
	path=$(eval echo "$path" 2>/dev/null) || return 1
	test -e "$path" || return 1
	test -d "$path" || path=$(dirname "$path")
	git -C "$path" rev-parse --show-toplevel 2>/dev/null
}

_git_infer_workdir() {
	local i
	for ((i=2; i<COMP_CWORD; i++)); do
		local arg="${COMP_WORDS[i]}"
		[[ "$arg" == -* ]] && continue
		local repo=$(_git_find_repo "$arg")
		if test -n "$repo"; then
			echo "$repo"
			return 0
		fi
	done
	return 1
}

_git_complete() {
	local cur_word="${COMP_WORDS[COMP_CWORD]}"
	local dir=$(dirname "$cur_word" 2>/dev/null)
	local workdir
	local repl
	case "$dir" in
	(.) ;;
	(/) repl=/;;
	(*) repl="${dir}/";;
	esac

	if test "$COMP_CWORD" = 1; then
		list=$(git help -a | awk '/^   /{print $1}')
		COMPREPLY=($(compgen -W "${list}" -- ${cur_word}))
		return
	elif test "${COMP_WORDS[1]}" == clone; then
		COMPREPLY=($(compgen -f -- "${COMP_WORDS[COMP_CWORD]}"))
		return
	elif test "${COMP_WORDS[1]}" == -C; then
		if test "$COMP_CWORD" == 2; then
			COMPREPLY=($(compgen -f -- "${COMP_WORDS[COMP_CWORD]}"))
			return
		fi
		workdir=$(eval cd "${COMP_WORDS[2]}" && pwd -P)
	fi

	local inferred
	if test -z "$workdir"; then
		workdir=$(_git_infer_workdir)
		test -n "$workdir" && inferred=1
	fi

	if test -z "$workdir" && test -n "$cur_word"; then
		workdir=$(_git_find_repo "$cur_word")
		test -n "$workdir" && inferred=1
	fi

	if test -n "$inferred"; then
		echo "Warning: use 'git -C $workdir'" >&2
	fi

	list=$(git ${workdir:+-C "$workdir"} for-each-ref refs --format '%(refname:short)' 2>/dev/null
		command ls -F -1 "$dir" 2>/dev/null | sed -e "s@^@$repl@"
		git ${workdir:+-C "$workdir"} rev-list --all 2>/dev/null | sed ${GIT_COMPLETE_REVLIST_MAX}q
	)

	COMPREPLY=($(compgen -W "${list}" -- ${cur_word}))
}
	complete -o bashdefault -o default -o nospace -F _git_complete git
fi

_y_complete() {
	cur_word="${COMP_WORDS[ COMP_CWORD ]}"
	list=$( git for-each-ref refs --format '%(refname:short)' 2> /dev/null )
	COMPREPLY=( $(compgen -W "${list}" -- ${cur_word}) )
}


complete -o bashdefault -o default -o nospace -F _y_complete y
