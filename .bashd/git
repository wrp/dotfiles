# Git related interactive functions


git_root() {
	local root
	root=$(command git rev-parse --absolute-git-dir)/.. \
	&& root=$(cd "$root" && pwd 2> /dev/null)/ \
	&& printf '%s\n' "${root}"
}
g() { git "$@"; }
git() {
	local v=$(command git --version)
	if test "$v" != "git version 2.48.0.rc2.30.gbf0d3122e9"; then
		warn Unexpected git version: $v
	fi

	test $# = 0 && { git .; g s; g b; return; }

	# replace numeric args with branch name
	local x prev tmp
	local -a args
	for x; do
		if test "$prev" != -n && test "$x" -ge 0 2> /dev/null; then
			tmp=( $(command git select-branch "$x") )
			if test -n "$tmp"; then
				echo "$x --> $tmp" >&2
				x=$tmp
			fi
		fi
		args+=( "$x" )
		prev=$x
	done
	set -- "${args[@]}"

	case $1 in
	(clone    ) git_clone "$@" ;;
	(root     ) git_root;;
	(*        ) command git "$@" ;;
	esac

}
ga() {
	# When running on both docker and outside, the repos seem to get corrupt
	# in such a way that `git status` cleans it up.  (That is, git diff-index
	# will fail until `git status` is run in that environment.)  So run
	# git status to "uncorrupt" the repo.  Terrible hack.
	command git status > /dev/null

	local msg force against=HEAD preamble
	if test "$1" = "-f"; then
		force=1
		shift
	fi
	if ! command git rev-parse --verify HEAD >/dev/null 2>&1; then
		# Initial commit: diff against an empty tree object
		against=$(command git hash-object -t tree /dev/null)
	fi
	if test -z "$force" && ! command git diff-index --quiet $against; then
		echo 'Repo is dirty.  -f to force (will also skip pre-commit check)' >&2
		return 1
	fi

	if test -z "$force"; then
		# If we abort, or git commit fails, we want to return to a clean state.
		# If commit succeeds, doing reset should be a no-op.  But, if user
		# asked to force, do not attempt to clean up.
		trap 'command git reset' RETURN
	fi
	command git add "$@";
	preamble=$(perl -E 'say substr join(", ", @ARGV), 0, 56' "${@##*/}")
	msg=$(command git diff --name-only --cached \
		| perl -0000 -nE 'if (tr/\n// > 1) {s@^@Add '"$preamble"'\n\n@} else {
			s/\n/ /g; s/^/Add / }; say'
	)
	if test -z "$msg"; then
		echo "Unable to generate commit message!" >&2
		return 1;
	fi
	command git commit ${force:+--no-verify} -m "$msg";
}
git_unpack() {
	local dir sha
	test $# = 0 && { echo 'Expected tarball arg' >&2; return 1; }
	for x; do
		local zip
		test "${x%.tar.gz}" = "$x" || zip=z
		dir="$(set -x; tar -${zip}tf "$x" | awk '{print $1}' FS=/ | sort -u)"
		if ! test "$(echo "$dir" | wc -l | tr -d ' ')" = 1; then
			echo "$x has more than 1 dir or contains newlines:"
			echo "$dir"
			return 1
		fi >&2

		test -e "$dir" && { echo $dir exists; return 1; }
		sha=$(md5sum "$x" | cut -d\  -f 1)
		tar -${zip}xf "$x" \
		&& cd "$dir" \
		&& command git init \
		&& command git add . \
		&& command git commit -n -m "Initial unpack: $sha $(basename $x)"
	done
}
git_clone() {
	local origin url
	shift    # discard 'clone'
	url=$1
	shift

	# Parse the url to specify a name for origin
	case $url in
	http*)
		# By default, remap name to use ssh
		if test -z "$HTTP_OK"; then
			echo 'Remapping http target to git@ to use ssh.  To force http, set HTTP_OK' >&2
			url=$(printf '%s\n' "$url" | sed -e 's|.*://|git@|' -e 's@/@:@')
			shift
		fi
	;;
	*github*) origin=github;;
	esac
	test -n "$origin" && echo "Setting origin=$origin" >&2
	set -- clone ${origin:+--origin="$origin"} "$url" "$@";
	command git "$@"
}
gr() { # Git recursive
	echo 'Stop using gr.  Use "g r" instead and fix it as needed' >&2
	return 1
}
