
in_path() {
	# Check if $1 is in PATH
	case ":$PATH:" in
	*:$1:*) return 0;;
	*) return 1;;
	esac
}
clear_path() {
	# Ensure that $1 is not in PATH
	PATH=$(echo "$PATH" | sed \
		-e "s@:$1:@:@g" \
		-e "s@^$1:@@" \
		-e "s@:$1\$@@" \
	)
}
append_path() { in_path "$1" || PATH="$PATH${PATH:+:}$1"; }
prepend_path() { in_path "$1" || PATH="$1${PATH:+:}$PATH"; }

make_hist_file() {
	{
	printf '#%s Shell %d' "$(date +%s)" "$$"
	if test "$PPID" -gt 0 2> /dev/null; then
		printf ', child of %s,' "$(ps -o pid=,comm= $PPID)"
	fi
	printf ' begins in %s' "$PWD"
	printf '\n'
	} | tr -s ' ' >> $1
	export HISTFILE=$1
}

debug_trap() {
	# Runs before a command in an interactive shell
	# warning: if you execute a loop, this will run for every iteration
	# TODO: figure out how to suppress that behavior
	if test "$IFS" != $' \t\n'; then
		echo "WARNING: IFS contains unexpected characters"
	fi

	history -a || echo 'WARNING: history -a failed'

	# Emit a warning if the history file is not updating
	# When a shell starts up, the debug trap is being called multiple times
	# before any commands have been executed.  In that case, fc emits no ouptut
	# and we do not want to emit a warning about the HISTFILE in that situation.
	if ! test -f "$HISTFILE" || ! {
		local last  # last is the first word of the most recent command
		last=$(fc -l -1 2> /dev/null | awk '{print $2; exit}')
		# Check the last command to ensure that the HISTFILE is updating.
		# Last command may be multi-line, hence the tac.
		test -z "$last" || tac "$HISTFILE" |
			awk '/^#/ && a++ > 2 {exit}
			$1 == "rh" || $1 == last {b++} END{ exit !b }' last="$last";
	} 2> /dev/null
	then
		echo 'WARNING: HISTFILE is not updating!!'
	fi
	if test -z "${TMUX}${NO_TMUX_OK}" && test "${FUNCNAME[1]}" != 'source'; then
		echo "WARNING: not running in TMUX! (set NO_TMUX_OK to suppress warning)"
	fi
} >&2
